const Injectables = require("../utilities/get-injectables.js");
const PathConverter = require("../utilities/path-converter.js");
const fs = require("fs");
const path = require("path");
const yargs = require("yargs");

const rootdir = path.resolve(__dirname, "../../");
const injectable_classes = Injectables.get_injectables({
  root_dir: rootdir,
  ts_config_file_path: rootdir + "/tsconfig.json",
  from_dir: rootdir + "/src",
});

const options = yargs.option("env", {
  alias: "e",
  description: "Sets the environment",
  type: "string",
}).argv;

const environment = options.env;
const envarjsonPath = `${rootdir}/vault/env.${environment}.json`;
if (!fs.existsSync(envarjsonPath)) {
  console.error("environment variables not found in vault");
}

const envars = JSON.parse(fs.readFileSync(envarjsonPath));

let contents = "/**\n";
contents += ` * This file was auto-generated by executing "npm run lambda:build --env=$ENV"\n`;
contents += ` * If you update this file, it will be overwritten.\n`;
contents += ` * @since ${new Date(Date.now()).toISOString()}\n`;
contents += ` */\n`;
contents += "import { fileURLToPath } from 'url';\n";
contents += "import { dirname } from 'path';\n";
contents +=
  "import { router } from './dist/core/services/lambda/lambda-router.js';\n";
contents +=
  "import { LambdaRoutesRegistry } from './dist/core/services/lambda/lambda-routes-registry.js';\n";
contents += "import { Application } from './dist/core/application.js';\n";
contents += "import { AppENV } from './dist/core/application/appEnv.js';\n";

for (let i = 0; i < injectable_classes.length; i++) {
  const injectable_class = injectable_classes[i];
  const dist_path = PathConverter.convert_src_to_dist({
    root_dir: rootdir,
    file_path: injectable_class.file_path,
  });
  const normalized_path = "./" + dist_path.replace(/\\/g, "/");
  contents += `import { ${injectable_class.class_name} } from "${normalized_path}";\n`;
}

contents += "\n\n";

contents += "const __filename = fileURLToPath(import.meta.url)\n";
contents += "const rootDir = dirname(__filename)\n";
contents += "Application.boot()\n";
contents += "Application.root(rootDir)\n";
contents += "Application.environment('" + environment + "')\n";

envars["APPLICATION_BUILD"] = new Date(Date.now()).toString();
for (const key in envars) {
  if (envars[key] === null) continue;
  let value = envars[key];
  if (typeof envars[key] === "string") {
    value = '"' + envars[key] + '"';
  }
  contents += "AppENV.set('" + key + "'," + value + ")\n";
}

for (let i = 0; i < injectable_classes.length; i++) {
  const injectable = injectable_classes[i];
  contents += `Application.container().bind(${injectable.class_name}).toSelf();\n`;
}

contents += "\n";
contents += `
Application.route().forEach(routeConfig => {
  const Controller = Application.container().get(routeConfig.Controller)
  LambdaRoutesRegistry.register(
    routeConfig.method,
    routeConfig.path,
    async (data) => {
      return await Controller[routeConfig.handler](data)
    }
  )
})
`;
contents += "\n";
contents += `
export const handler = async (event) => {
  try {
    const response = await router(event)
    return {
      statusCode: response.code,
      body: JSON.stringify(response.data)
    }
  } catch (error) {
    return {
      statusCode: error.code ?? 500,
      body: JSON.stringify({ error: error.message ?? 'unknown exception' }),
    }
  }
}
`;

fs.writeFileSync(`${rootdir}/index.mjs`, contents);
